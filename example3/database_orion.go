// Code generated by orion. DO NOT EDIT.

package example

import "github.com/lovromazgon/orion"

type setIn struct {
	Key   string
	Value string
}

type setOut struct {
	Error error
}

type getIn struct {
	Key string
}

type getOut struct {
	Value string
	Error error
}

type deleteIn struct {
	Key string
}

type deleteOut struct {
	Error error
}

type DatabaseWithContract interface {
	Database
	withContract()
}

func NewDatabaseWithContract(db Database, handler orion.BreachHandler) DatabaseWithContract {
	if handler == nil {
		// no handler means we don't enforce the contract
		return databasePassthrough{db}
	}

	dbc := databaseWithContract{
		db: db,
		o:  orion.New(handler),
	}

	c := newContract(db)
	c1, ok := any(c).(interface {
		Get(getIn, getOut) orion.Breach
	})
	if ok {
		dbc.contractGet = c1.Get
	}

	c2, ok := any(c).(interface {
		Set(setIn, setOut) orion.Breach
	})
	if ok {
		dbc.contractSet = c2.Set
	}

	c3, ok := any(c).(interface {
		Delete(deleteIn, deleteOut) orion.Breach
	})
	if ok {
		dbc.contractDelete = c3.Delete
	}

	return dbc
}

type databaseWithContract struct {
	db Database
	o  *orion.O

	contractGet    func(getIn, getOut) orion.Breach
	contractSet    func(setIn, setOut) orion.Breach
	contractDelete func(deleteIn, deleteOut) orion.Breach
}

func (d databaseWithContract) withContract() {}

func (d databaseWithContract) Get(key string) (val string, err error) {
	if d.contractGet != nil {
		defer func() {
			in := getIn{
				Key: key,
			}
			out := getOut{
				Value: val,
				Error: err,
			}
			if b := d.contractGet(in, out); b != orion.NoBreach {
				d.o.AddBreach(b)
			}
		}()
	}
	return d.db.Get(key)
}

func (d databaseWithContract) Set(key, value string) (err error) {
	if d.contractSet != nil {
		defer func() {
			in := setIn{
				Key:   key,
				Value: value,
			}
			out := setOut{
				Error: err,
			}
			if b := d.contractSet(in, out); b != orion.NoBreach {
				d.o.AddBreach(b)
			}
		}()
	}
	return d.db.Set(key, value)
}

func (d databaseWithContract) Delete(key string) (err error) {
	if d.contractDelete != nil {
		defer func() {
			in := deleteIn{
				Key: key,
			}
			out := deleteOut{
				Error: err,
			}
			if b := d.contractDelete(in, out); b != orion.NoBreach {
				d.o.AddBreach(b)
			}
		}()
	}
	return d.db.Delete(key)
}

type databasePassthrough struct{ Database }

func (d databasePassthrough) withContract() {}
